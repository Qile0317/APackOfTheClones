#' The apotc (APackOfTheClones) reduction class
#'s
#' A class for storing information about T cell clonal expansion in the seurat
#' `reductions` attribute under [["apotc"]]
#'
#' @slot clusters The original circle packing "reduction" with no modifications,
#' a list of clusterlists that may include NAs.
#' @slot centroids Centroids of the clusters which default to the same centroids
#' of the clusterlists, tho this also means clusters has to be iterated over
#' everytime the plotting function is called. but it wont be slow probably
#' @slot clone_sizes the original unscaled clone sizes. Not sure if I should
#' leave it named
#' @slot clone_scale_factor scale factor to multiply `clone_sizes` by when
#' running the clonal expansion plotting algorithms
#' @slot rad_scale_factor scale factor to multiply the radii in clusterlists by
#' after they have all been computed to increase spacing between circles. Might
#' also be better in the future to instead just have a number to subtract :/
#' @slot cluster_colors character vector indicating coloration of each cluster
#' @slot reduction_base character indicating the reduction the plotting was
#' based off of
#' @slot label_coords list of numeric vectors of length two indicating the (x,y)
#' coordinates of each label if plotted
#'
#' @export
#'
setClass(
    Class = "apotc",
    slots = c(
        clusters = 'list',
        num_clusters = 'numeric',
        centroids = 'list',
        clone_sizes = 'list',
        clone_scale_factor = 'numeric',
        rad_scale_factor = 'numeric',
        cluster_colors = 'character',
        reduction_base = 'character',
        labels = 'character',
        label_coords = 'list'
    )
)

# it might be better to store it in @misc? but shouldnt matter too much

# initialize the reduction object from precomputed clusterlists
initialize_apotc <- function(
    num_clusters, clone_scale_factor, rad_scale_factor, reduction_base
) {
    empty_list <- vector("list", num_clusters)
    methods::new(
        Class = 'apotc',
        clusters = empty_list,
        num_clusters = num_clusters,
        centroids = empty_list,
        clone_sizes = empty_list,
        clone_scale_factor = clone_scale_factor,
        rad_scale_factor = rad_scale_factor,
        cluster_colors = gg_color_hue(num_clusters),
        reduction_base = reduction_base,
        labels = gen_labels(num_clusters),
        label_coords = empty_list
    )
}

# readability function
get_apotc <- function(seurat_obj) {
    seurat_obj@reductions[['apotc']]
}

# warn helper
run_apotc_warn_str <- function(
    seurat_obj, reduction_base, clone_scale_factor, ORDER, scramble
) {
    if (tolower(reduction_base) == 'apotc') {
        return("please only use the umap, tsne, or pca reduction")
    }
    if (is.null(seurat_obj@reductions[[attempt_correction(reduction_base)]])) {
        return(paste(
            "No", reduction_base, "reduction found on the seurat object,",
            "ensure the the reduction has been computed. Otherwise, did you",
            "mean", closest_word(reduction_base), "?"
        ))
    }
    if (should_estimate(clone_scale_factor) && (clone_scale_factor <= 0)) {
        return("clone_scale_factor has to be a positive number")
    }
    if (ORDER && scramble) {
        return("ORDER and scramble are both TRUE, please set only one to TRUE")
    }
    return(NULL)
}

#' @title Run the APackOfTheClones method on a combined Seurat object for
#' downstream visualization of clonal expansion
#'
#' @description Computes all necessary information for an APackOfTheClones
#' clonal expansion plot and stores it in the seurat object at
#' `seurat_obj@reduction[['apotc']]` for use later with `APOTCPlot`. Gets sizes
#' of unique clones and utilizes a circle-packing algorithm to pack circles
#' representing individual clones in approximately the same dimensional
#' reduction (`reduction_base`) coordinates.
#'
#' @details If the user wishes to manually customize/fix the expansion plot
#' generated by `APOTCPlot`, the circular packing information can be modified
#' with the `AdjustAPOTC` function, or alternatively accessed via the syntax
#' `seurat_obj@reduction[['apotc']]` which harbours the custom S4 object of the
#' class `apotc`. Please read the function level documentation for the mentioned
#' functions and class, and also the web-only user vignette for a walkthrough of
#' the inner workings of the package.
#'
#' @param seurat_obj Seurat object with one or more dimension reductions. Must
#' already have been integrated with a T cell library via
#' `integrate_tcr(seurat_obj, tcr_df)`
#' @param reduction_base character. The seurat reduction to base the clonal
#' expansion plotting on. Defaults to `'umap'` but can also be `'tsne'` or
#' `'pca'`. If `'pca'``, the cluster coordinates will be based on PC1 and PC2.
#' However, generally APackOfTheClones is used for displaying UMAP and
#' occasionally t-SNE versions to intuitively highlight clonal expansion
#' @param clone_scale_factor Dictates how much to scale each circle(between 0,1)
#' radius when converting from clonotype counts into circles that represent
#' individual clonotypes. The argument defaults to the character `"auto"`, and
#' if so, the most visually pleasing factor will be estimated
#' @param rad_scale_factor numeric between 0 and 1. This value decreases the
#' radius of the smallest clones by this scale factor. And the absolute value
#' of this decrease will be applied to all packed circles, effectively shrinking
#' all circles on the spot, and introduce more spacing in between
#' @param ORDER logical. Decides if the largest clone circles should be at
#' cluster centroids
#' @param scramble logical. Decides if the clone circles within each cluster
#' should be randomly scrambled when plotted
#' @param try_place If `TRUE`, always minimizes distance from a newly placed
#' circle to the origin in the circle packing algorithm
#' @param repulse If `TRUE`, will attempt to push overlapping clusters away from
#' each other
#' @param repulsion_threshold numeric. The radius that clonal circle clusters
#' overlap is acceptable when repulsing
#' @param repulsion_strength numeric. The smaller the value the less the
#' clusters repulse each other per iteration, and vice versa
#' @param max_repulsion_iter integer. The number of repulsion iterations
#' @param verbose logical. Decides if visual cues print to the R console of the
#' progress
#'
#' @return A modified version of the input seurat object with a new object in
#' the `@reduction` attribute named `apotc`, which harbors data necessary for
#' visualizing the clonal expansion of the cells with the `APOTCPlot()` function
#'
#' @seealso [APOTCPlot()], [AdjustAPOTC()]
#'
#' @export
#'
#' @examples
#' # unfinished
#'
RunAPOTC <- function(
    seurat_obj,
    reduction_base = "umap",
    clone_scale_factor = "auto",
    rad_scale_factor = 0.95,
    ORDER = TRUE,
    scramble = FALSE,
    try_place = FALSE,

    repulse = FALSE,
    repulsion_threshold = 1,
    repulsion_strength = 1,
    max_repulsion_iter = 20L,
    verbose = TRUE
) {
    call_time <- Sys.time()

    reduction_base <- attempt_correction(reduction_base)

    # errors/warnings:
    warn_str <- run_apotc_warn_str(
        seurat_obj, reduction_base, clone_scale_factor, ORDER, scramble
    )
    if (!is.null(warn_str)) { stop(warn_str) }
    if (rad_scale_factor < 0 || rad_scale_factor > 1) {
        stop("rad_scale_factor has to be between 0 and 1")
    }

    # actual run
    if (verbose) {message("Initializing APOTC run")}

    if (should_estimate(clone_scale_factor)) {
        clone_scale_factor <- estimate_clone_scale_factor(seurat_obj, verbose)
    }

    rad_decrease <- convert_to_rad_decrease(rad_scale_factor,clone_scale_factor)

    # add seurat command
    if (!(is.null(seurat_obj@commands[["RunAPOTC"]]) && is.null(seurat_obj@commands[["RunAPOTC"]]))) {
        message("overriding pervious APOTC run results")
    }
    seurat_obj@commands[["RunAPOTC"]] <- make_apotc_command(call_time)

    # initialize apotc S4 class
    apotc_obj <- initialize_apotc(
        get_num_clusters(seurat_obj),
        clone_scale_factor,
        rad_scale_factor, # maybe should be rad_decrease in the future?
        reduction_base
    )

    # infer clone sizes and centroids
    apotc_obj <- add_raw_clone_sizes(apotc_obj, seurat_obj)
    initial_centroids <- get_cluster_centroids(seurat_obj, reduction_base)

    # pack the clusterlists
    packed_clusters <- pack_into_clusterlists(
        sizes = get_processed_clone_sizes(apotc_obj),
        centroids = initial_centroids,
        num_clusters = apotc_obj@num_clusters,
        rad_decrease = rad_decrease,
        ORDER = ORDER,
        scramble = scramble,
        try_place = try_place,
        verbose = verbose
    )

    if (repulse) {
        results <- get_repulsed_clusterlists_and_centroids(
            packed_clusters, initial_centroids, apotc_obj@num_clusters,
            repulsion_threshold, repulsion_strength, max_repulsion_iter, verbose
        )
        packed_clusters <- results[[1]]
        initial_centroids <- results[[2]]
    }

    # add the clusterlists and centroids to the obj
    apotc_obj@clusters <- packed_clusters
    apotc_obj@centroids <- initial_centroids
    apotc_obj@label_coords <- initial_centroids

    # add the finished apotc object to reductions, print message, and return
    seurat_obj@reductions[['apotc']] <- apotc_obj

    if (verbose) {
        print_completion_time(call_time)
    }

    seurat_obj
}
