#' @title
#' Run the APackOfTheClones method on a combined Seurat object for
#' downstream visualization of clonal expansion
#'
#' @description
#' Computes all necessary information for an APackOfTheClones
#' clonal expansion plot and stores it in the seurat object at
#' `seurat_obj@reduction[['apotc']]` for use later with `APOTCPlot`. Gets sizes
#' of unique clones and utilizes a circle-packing algorithm to pack circles
#' representing individual clones in approximately the same dimensional
#' reduction (`reduction_base`) coordinates.
#'
#' @details If the user wishes to manually customize/fix the expansion plot
#' generated by `APOTCPlot`, the circular packing information can be modified
#' with the `AdjustAPOTC` function, or alternatively accessed via the syntax
#' `seurat_obj@reduction[['apotc']]` which harbours the custom S4 object of the
#' class `apotc`. Please read the function level documentation for the mentioned
#' functions and class, and also the web-only user vignette for a walkthrough of
#' the inner workings of the package.
#'
#' @param seurat_obj Seurat object with one or more dimension reductions. Must
#' already have been integrated with a T cell library via
#' `integrate_tcr(seurat_obj, tcr_df)`
#' @param reduction_base character. The seurat reduction to base the clonal
#' expansion plotting on. Defaults to `'umap'` but can also be `'tsne'` or
#' `'pca'`. If `'pca'``, the cluster coordinates will be based on PC1 and PC2.
#' However, generally APackOfTheClones is used for displaying UMAP and
#' occasionally t-SNE versions to intuitively highlight clonal expansion
#' @param clone_scale_factor Dictates how much to scale each circle(between 0,1)
#' radius when converting from clonotype counts into circles that represent
#' individual clonotypes. The argument defaults to the character `"auto"`, and
#' if so, the most visually pleasing factor will be estimated
#' @param rad_scale_factor numeric between 0 and 1. This value decreases the
#' radius of the smallest clones by this scale factor. And the absolute value
#' of this decrease will be applied to all packed circles, effectively shrinking
#' all circles on the spot, and introduce more constant spacing in between
#' @param order_clones logical. Decides if the largest clone circles should be
#' near cluster centroids. This is highly recommended to be set to TRUE.
#' @param scramble_clones logical. Decides if the clone circles within each
#' cluster should be randomly scrambled when plotted. Note that solely this
#' argument or order_clones may be `TRUE` at once.
#' @param try_place If `TRUE`, always minimizes distance from a newly placed
#' circle to the origin in the circle packing algorithm
#' @param repulse If `TRUE`, will attempt to push overlapping clusters away from
#' each other
#' @param repulsion_threshold numeric. The radius that clonal circle clusters
#' overlap is acceptable when repulsing
#' @param repulsion_strength numeric. The smaller the value the less the
#' clusters repulse each other per iteration, and vice versa
#' @param max_repulsion_iter integer. The number of repulsion iterations
#' @param verbose logical. Decides if visual cues print to the R console of the
#' progress
#'
#' @return A modified version of the input seurat object with a new object in
#' the `@reduction` attribute named `apotc`, which harbors data necessary for
#' visualizing the clonal expansion of the cells with the [APOTCPlot] function
#'
#' @seealso [APOTCPlot], [AdjustAPOTC]
#'
#' @export
#'
#' @examples
#' # unfinished
#'
RunAPOTC <- function(
    seurat_obj,
    reduction_base = "umap",
    clonecall = "strict",
    clone_scale_factor = "auto",
    rad_scale_factor = 0.95,
    order_clones = TRUE,
    scramble_clones = FALSE,
    try_place = FALSE,
    repulse = FALSE,
    repulsion_threshold = 1,
    repulsion_strength = 1,
    max_repulsion_iter = 20L,
    override = FALSE,
    verbose = TRUE,
    extra_filter = NULL,
    ...
) {
    call_time <- Sys.time()

    if (verbose) message("Initializing APOTC run...\n")

    # compute inputs
    reduction_base <- attempt_correction(reduction_base)

    if (should_estimate(clone_scale_factor)) {
        clone_scale_factor <- estimate_clone_scale_factor(seurat_obj, clonecall)
        if (verbose) message(paste(
            "Setting `clone_scale_factor` to", clone_scale_factor
        ))
    }

    #clonecall <- scRepertoire:::.theCall(clonecall, seurat_obj@meta.data)
    clonecall <- .convertClonecall(clonecall)

    metadata_filter_string <- parse_to_metadata_filter_str(
        metadata_filter = extra_filter, varargs_list = list(...)
    )

    obj_id <- parse_to_object_id(
        reduction_base = reduction_base, clonecall =  clonecall,
        varargs_list = list(...), metadata_filter = extra_filter
    )

    RunAPOTC_parameter_checker(hash::hash(as.list(environment())))

    # run the packing algos
    apotc_obj <- ApotcData(
        seurat_obj, metadata_filter_string, clonecall, reduction_base,
        clone_scale_factor, rad_scale_factor
    )

    if (verbose) message("Packing clones into clusters\n")

    apotc_obj <- circlepackClones(
        apotc_obj, order_clones, scramble_clones, try_place, verbose
    )

    if (verbose) message("Repulsing clusters\n")

    if (repulse) {
        apotc_obj <- repulseClusters(
            apotc_obj, repulsion_threshold, repulsion_strength,
            max_repulsion_iter, verbose
        )
    }

    # store the apotc object in the correct slot with the correct id
    seurat_obj <- setApotcData(seurat_obj, obj_id, apotc_obj)

    seurat_obj <- log_and_index_command(
        seurat_obj, "RunAPOTC", command_obj = make_apotc_command(call_time)
    )

    if (verbose) print_completion_time(call_time)
    seurat_obj
}

RunAPOTC_parameter_checker <- function(args) {

	if (is.null(args[["seurat_obj"]]@reductions[[attempt_correction(args[["reduction_base"]])]])) {
		stop(paste(
			"No", args[["reduction_base"]], "reduction found on the seurat object,",
			"ensure the the reduction has been computed. Otherwise, did you",
			"mean:", closest_word(args[["reduction_base"]], c("umap", "tsne", "pca"))
		))
	}

	if (args[["clone_scale_factor"]] <= 0 || args[["clone_scale_factor"]] > 1) {
		stop("`clone_scale_factor` has to be a positive number in (0, 1]")
	}

    if (args[["rad_scale_factor"]] <= 0 || args[["rad_scale_factor"]] > 1) {
		stop("`rad_scale_factor` has to be a positive number in (0, 1]")
	}

	if (args[["order_clones"]] == args[["scramble_clones"]]) {
		stop(paste(
            "`order_clones` and `scramble_clones` cannot both be",
            args[["order_clones"]]
        ))
	}

    if (args[["repulse"]]) {
        if (args[["repulsion_threshold"]] <= 0) {
            stop("`repulsion_threshold` has to be a positive number")
        }
        if (args[["repulsion_strength"]] <= 0) {
            stop("`repulsion_strength` has to be a positive number")
        }
        if (args[["max_repulsion_iter"]] <= 0) {
            stop("`max_repulsion_iter` has to be a positive number")
        }
    }

    if (args[["override"]] && containsApotcRun(args[["seurat_obj"]], args[["obj_id"]])) {
        stop(paste(
            "An APackOfTheClones run with the the parameters", args[["obj_id"]],
            "appears to already have been ran. If this is a mistake,",
            "set the `override` argument to `FALSE` and re-run."
        ))
    }
}
