---
title: "APackOfTheClones-primary"
description: >
  A full walkthrough of the clonal expansion visualization workflow.
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{APackOfTheClones-primary}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
data: 'Compiled: `r format(Sys.Date(), "%B %d, %Y")`'
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

knitr::opts_chunk$set(echo = FALSE)
options(rmarkdown.html_vignette.check_title = FALSE)
options(repos = c(CRAN = "http://cran.rstudio.com"))

# utility functions
head <- function(df) {
  knitr::kable(utils::head(df))
}

quiet_load <- function(pkg, CRAN = TRUE, dev_dir = "Qile0317/") {
  if (!require(pkg, quietly = TRUE, character.only = TRUE)) {
    if (CRAN) {
      invisible(install.packages(pkg, quiet = TRUE, verbose = FALSE, character.only = TRUE))
    } else {
      suppressWarnings(suppressMessages(
        devtools::install_github(paste(dev_dir, pkg, sep = ""))
      ))
    }
  }
  suppressPackageStartupMessages(invisible(require(pkg, character.only = TRUE)))
}

quiet_load_all_CRAN <- function(...) {
  pkgs <- list(...)
  for (pkg in pkgs) {quiet_load(pkg)}
}

# load packages and data
quiet_load_all_CRAN("ggplot2", "cowplot", "Seurat", "devtools")
# TODO use a nice looking dataset
```

```{r setup}
suppressPackageStartupMessages(library(APackOfTheClones))
```

## Introduction

Single-cell RNA sequencing (scRNA-seq) and T/B cell receptor (TCR) sequencing are popular techniques for studying immune cell function and disease. The combined use of such data can provide valuable insights into the immune system, including clonal expansion. `APackOfTheClones` provides a simple, easily customizable, and publication-ready method to intuitively visualize clonal expansion between different cell clusters with `ggplot2`, and can be easily slotted into any analysis pipeline.

The method counts clonotypes, and using a dimensional reduction (e.g. UMAP) of all cells in a single cell immune profiling experiment as a base, it circle-packs all clone sizes directly as circles within circular clusters according to its seurat cluster. The advantage of this method compared to other (very limited) visualizations of clonal expansion out there is that its arguably much more intuitive. To see it in action, see [this paper](https://doi.org/10.1126/sciimmunol.abg6356) and [this paper](https://doi.org/10.1111/all.15399).

Basic familiarity with the `R` language, the `Seurat` package, and the `scRepertoire` package *VERSION TWO* is assumed. As version two of `scRepertoire` is relatively new and introduces some small breaking changes, it is *essential* that its [new vignettes](https://www.borch.dev/uploads/screpertoire/) are read.

In this vignette, the most essential functionalities of the package are covered, from preparing the data with scRepertoire, to producing and fine-tuning a barebones visualization of clonal expansion.

### Setting up the Seurat Object and Receptor Library with scRepertoire

The premise of the package is that it provides an additional analysis tool on top of `scRepertoire`'s many functions, which are all ran after combining all TCR/BCR contigs into clones, and integrating the clonal information into a seurat object with a dimensional reduction(s). Here are the corresponding vignettes to read in order for combining contigs:

1. [Loading Data](https://www.borch.dev/uploads/screpertoire/articles/loading)
2. [Combining Contigs into Clones](https://www.borch.dev/uploads/screpertoire/articles/combining_contigs)
3. [Additional Processing Steps (optional)](https://www.borch.dev/uploads/screpertoire/articles/processing)

<details>

  <summary>
  **An example of contig combination**
  </summary>

```{r, combineTCR, echo = TRUE}
# load in the corresponding 6-sample TCR contigs from scRepertoires
contig_list <- get(data("contig_list", package = "scRepertoire"))

# combine the TCR contigs into clones with custom samples
combined_contig_list <- scRepertoire::combineTCR(
  contig_list,
  samples = c("P17B", "P17L", "P18B", "P18L", "P19B", "P19L", "P20B", "P20L"),
  removeNA = FALSE, 
  removeMulti = FALSE, 
  filterMulti = FALSE
)

head(combined_contig_list[[1]])
```

</details>

For integrating the clonal information, ```scRepertoire::combineExpression``` is the function used [to do so](https://www.borch.dev/uploads/screpertoire/articles/attaching_sc). However, for convenience and safety, an `APackOfTheClones` wrapper ```combineSeuratExpression``` is provided, which will produce a functionally equivalent object, which can *only* work on seurat objects:

```{r, echo = FALSE}
# remove the raw contig_list from memory
rm("contig_list")

# load the seurat object (feel free to change to the full scRep_example for CRAN)
pbmc <- get(data("combined_pbmc"))
```

```{r, combining, echo = TRUE}
# a seurat object named `pbmc` is loaded
# a combined contig list is loaded named `combined_contig_list`
pbmc <- combineSeuratExpression(
  input.data = combined_contig_list,
  sc.data = pbmc,
  cloneCall = "gene",
  proportion = TRUE
)

print(pbmc)
```

And as a reference, here is the corresponding UMAP plot of the seurat object
```{r, umap, echo = TRUE}
pbmc_umap_plot <- UMAPPlot(pbmc)
pbmc_umap_plot
```

## Simple ball packing visualization

```vizAPOTC``` (short for "visualize APackOfTheClones") is the main convenience function of the package to directly produce the ball packing clonal expansion plot. It takes in a main argument of a combined seurat object (with a long list of optional arguments which will be covered in later sections), and outputs a ggplot object:

```{r, initial_vizapotc, echo = TRUE}
vizAPOTC(pbmc, verbose = FALSE)
```

### Key characteristics of the plot

* One should notice the immediate correspondence of circular clusters to umap clusters, and be able to derive some immediate insights about which clusters have expanded.
* The clonotype counts for each seurat cluster corresponds to their position and color in the original UMAP centroids
* The most expanded clonotypes are in the center of each circle cluster with larger sizes, symbolizing increased expansion
* On the plot, there is a somewhat imperfect visual legend of the relative clone sizes
* Some clusters have considerable visual overlap
* The returned plot is a fully customizable `ggplot` object

The resulting clonal expansion plot may not be visually satisfactory on the first run without customizations from optional arguments. These arguments and other `ggplot` tricks will be covered to fine-tune the visualization until publication-ready.

## Working with a data subset

A new feature of version 1 is the ability to conviniently visualize subsets / different versions of the seurat data, for example only the control samples or samples from one treatment condition. The arguments to do so are:

```{r, echo = TRUE, eval = FALSE}
reduction_base = "umap",
clonecall = "strict",
...,
extra_filter = NULL,
```

`reduction_base` indicates what each cl

## Customization of visual parameters

TODO

### Cluster repulsion

Considerable visual overlap between clusters (due to the algorithm's attempt to fit clusters to the original UMAP coordinates) may ocurr sometimes and obstruct eachother excessively.

To account for this, there are four optional arguments:

```{r, echo = TRUE, eval = FALSE}
repulse = TRUE,
repulsion_threshold = 1,
repulsion_strength = 1,
max_repulsion_iter = 10
```

For more details on them, read the "Arguments" section in the function documentation. Briefly, first, to make the circle clusters move away from eachother, `repulse` should be set to `TRUE`, and the function should be ran AGAIN. (If you feel this excessive re-running takes too long or is inefficient for your workflow in its current form, see the vignette `TODO`.)

Setting repulse to TRUE with those default parameters should probably yield something like the following:

```{r, repulse, echo = TRUE, eval = FALSE}
TODO
```

If you are still unhappy with the spacing of the plot, see the following ways to adjust the spacing:

* `repulsion_threshold` indicates the amount of `ggplot2` units of overlap between clusters that are acceptable. It defaults to `1`, meaning that two clusters that overlap by about 1 unit are considered by the repulsion algorithm to not be overlapping. Increasing this number will increase the amount of overlap between clusters, and decreasing this number will do the opposite, while decreasing it to negative values will incur additional spacing between clusters. However, using negative spacing may cause the plot to look very spaced out. Keep reading to see alternatives to doing so.
* `repulsion_strength` relates to how much the clusters should repel each other. The repulsion algorithm works in iterations, where for each iteration, each cluster "pushes" each other away from eachother by some amount. Increasing this value will cause extra "pushing" during each iteration. However, increasing this factor too much may result once again in a very visually unpleasant plot.
* `max_repulsion_iter` indicates the number of iterations where clusters should repel eachother. Increasing this number would ensure that clusters will (almost always) for sure not be overlapping. A trick with this parameter to make more pleasant plots is to decrease `repulsion_strength` and increase `max_repulsion_iter` to possibly make a more pleasant arrangement of clusters.

### Managing the clone size legend

TODO

The plot we've generated here has a size legend on the top left, but we see that it is partially outside of the plot. Unfortunately the algorithm for placing the legend is far from perfect in version 0 so the user will have to do a little extra work.

There are the following six parameters to adjust the legend:

```{r, legend_params, echo = TRUE, eval = FALSE}
add_size_legend = TRUE,
legend_sizes = "auto",
legend_position = "auto",
legend_buffer = 0.2 ,
legend_color = "#808080",
legend_spacing = "auto"
```

TODO

More details about these arguments can be read in the function documentation.

### Visually scaling circle sizes

TODO

### Other modifications

TODO

## Final product

That's about it for the most basic functionalities of the clonal expansion visualization function. Remember to save the plot first as an `.svg` file with ```ggplot2::ggsave``` for maximal resolution (especially of the circles) for publication.

For inspiration of how it could practically look like in a real paper context, see the following papers where the original julia implementation of APackOfTheClones was used:

* [Single-cell analysis pinpoints distinct populations of cytotoxic CD4+ T cells and an IL-10+CD109+ $T_{H}2$ cell population in nasal polyps](https://doi.org/10.1126/sciimmunol.abg6356)
* [Recombinant multimeric dog allergen prevents airway hyperresponsiveness in a model of asthma marked by vigorous $T_{H}2$ and $T_{H}17$ cell responses](https://doi.org/10.1111/all.15399)

Lastly, for fun, here's a side-by-side comparison of the UMAP plot and the clonal expansion plot:

```{r, final, echo = TRUE}
library(ggplot2)
library(cowplot)

cowplot::plot_grid(
  UMAPPlot(pbmc) + coord_fixed() + ggtitle("scRNA-seq UMAP"),
  vizAPOTC(pbmc) + ggtitle("APackOfTheClones clonal expansion plot"),
  labels = "AUTO"
)
```

There are a lot more features to the package to be read, see
* RunAPOTC + AdjustAPOTC + APOTCPlot workflow, and the ApotcDataId getters
