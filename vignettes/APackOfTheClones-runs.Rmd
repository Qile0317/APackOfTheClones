---
title: "Storing and Fine-Tuning APackOfTheClones Runs"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{APackOfTheClones-runs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
data: 'Compiled: `r format(Sys.Date(), "%B %d, %Y")`'
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

knitr::opts_chunk$set(echo = FALSE)
options(rmarkdown.html_vignette.check_title = FALSE)
options(repos = c(CRAN = "http://cran.rstudio.com"))

# utility functions
head <- function(df) {
  knitr::kable(utils::head(df))
}

quiet_load <- function(pkg, CRAN = TRUE, dev_dir = "Qile0317/") {
  if (!require(pkg, quietly = TRUE, character.only = TRUE)) {
    if (CRAN) {
      invisible(install.packages(pkg, quiet = TRUE, verbose = FALSE, character.only = TRUE))
    } else {
      suppressWarnings(suppressMessages(
        devtools::install_github(paste(dev_dir, pkg, sep = ""))
      ))
    }
  }
  suppressPackageStartupMessages(invisible(require(pkg, character.only = TRUE)))
}

quiet_load_all_CRAN <- function(...) {
  pkgs <- list(...)
  for (pkg in pkgs) {quiet_load(pkg)}
}

# load packages and data
quiet_load_all_CRAN("ggplot2", "cowplot", "Seurat", "devtools")
# TODO use a nice looking dataset
```

```{r setup}
suppressPackageStartupMessages(library(APackOfTheClones))
```

## Introduction

As demonstrated in `vignette("APackOfTheClones-primary")`, after processing the seurat & clonotype data properly with `scRepertoire`, `vizAPOTC` provides a direct way to produce the ball-packing clonal expansion visualization, though for select users it may be somewhat clunky, if certain parameters need to be readjusted constantly. In this vignette, more details about how APackOfTheClones runs can be stored and re-adjusted will be covered - mainly through `RunAPOTC`, `APOTCPlot`, and `AdjustAPOTC`. Ensure to read the aforementioned vignette before this one.

<details>

  <summary>
  **As a reminder, here's how to set up the seurat object and clonotype data**
  </summary>

```{r, setup_seurat, echo = TRUE}
# load in the corresponding 6-sample TCR contigs from scRepertoire
contig_list <- get(data("contig_list", package = "scRepertoire"))

# combine the TCR contigs into clones with custom samples
combined_contig_list <- scRepertoire::combineTCR(
  contig_list,
  samples = c("P17B", "P17L", "P18B", "P18L", "P19B", "P19L", "P20B", "P20L"),
  removeNA = FALSE, 
  removeMulti = FALSE, 
  filterMulti = FALSE
)

# a seurat object named `pbmc` is loaded
pbmc <- combineSeuratExpression(
  input.data = combined_contig_list,
  sc.data = pbmc,
  cloneCall = "gene",
  proportion = TRUE
)

print(pbmc)
```

</details>

### Overview

All of `vizAPOTC`'s arguments are actually derived from `RunAPOTC` and `APOTCPlot`. The former is responsible for storing data of the S4 class `ApotcData` in the seurat object under a named list in `@misc$APackOfTheClones` under some character run ID, and the latter allows the visualization of these data objects with some customization. `AdjustAPOTC` has many arguments for adjusting the data associated with some APackOfTheClones run stored by `RunAPOTC`, including adjusting cluster positions, colors, repulsion, etc. which can be visualized again with `APOTCPlot`.

## Managing APackOfTheClones run data

`RunAPOTC` has approximate the first half of `vizAPOTC`'s arguments until `max_repulsion_iter`, meaning it has all the data subsetting, circle size scaling, and cluster repulsion capabilities covered in the previous vignette. The most essential difference is the presence of the argument `run_id`, which corresponds to an id for the `ApotcData` object. If left blank, one will be automatically generated in the following format:

> `reduction_base;clonecall;keyword_arguments;extra_filter`

where if keyword arguments and extra_filter are underscore (`_`) characters if there was no input for the `...` and `extra_filter` parameters.

```{r, eval = FALSE}
# Here is the function ran with its default parameters
pbmc <- RunAPOTC(combined_pbmc)

#> Initializing APOTC run...
#> * Setting `clone_scale_factor` to 0.3
#> * id for this run: umap;CTstrict;_;_
#>
#> Packing clones into clusters
#> [==================================================] 100%
#> 
#> repulsing all clusters | max iterations = 20
#> [==================================================] 100%
#>
#> Completed successfully, time elapsed: 0.155 seconds
#>
```

```{r, runapotc_default, include = FALSE}
pbmc <- RunAPOTC(pbmc, verbose = FALSE)
```

From the verbal queues, one can see how the `run_id` was set. Here's it ran again but with more optional arguments and a custom `run_id`:

```{r, runapotc2}
pbmc <- RunAPOTC(
    pbmc, run_id = "sample17", orig.ident = c("P17B", "P17L"), verbose = FALSE
)
```

### Utilities for Managing APackOfTheClones Runs

It is to note that the data abstraction here with a `run_id` is intentional, and users should not manually touch any of the `ApotcData` objects with the seurat object unless they are extremely familiar with the latest internal implementation. Instead, here is a collection of functions that may be useful:

- `getApotcDataIds(pbmc)` gets all current `run_id`'s, if any.
- `getLastApotcDataId(pbmc)` gets the latest `run_id`, if any.
- `containsApotcRun(pbmc, run_id = "foo")` returns whether a `run_id` exists in the seurat object.
- `deleteApotcData(pbmc, run_id = "foo")` deletes *all data* associated with a certain `run_id`.

## APOTCPlot

TODO

## AdjustAPOTC

TODO
